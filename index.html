<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>病院在庫管理</title>
  <style>
    :root { --gap: 12px; }
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; padding: 16px; line-height: 1.6; }
    h1 { font-size: 28px; margin: 8px 0 16px; }
    .row { margin-bottom: var(--gap); }
    .muted { color: #666; }
    .ok { color: #0a7b27; font-weight: 600; }
    .err { color: #b00020; font-weight: 600; }
    .code { font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; background: #f5f5f7; padding: 2px 6px; border-radius: 4px; }
    .btn { padding: 10px 14px; border: 1px solid #ddd; border-radius: 8px; background: #fafafa; cursor: pointer; }
    .btn:active { transform: translateY(1px); }
    .btn.primary { background: #1a73e8; border-color: #1a73e8; color: #fff; }
    .btn.warn { background: #ffe9e9; border-color: #f3b4b4; color: #b00020; }
    input[type="text"]{ width: 100%; padding: 10px; font-size: 16px; box-sizing: border-box; }
    .grid { display: grid; gap: 10px; }
    .actions { display: flex; gap: 10px; flex-wrap: wrap; }
    .item { display: grid; grid-template-columns: 1fr auto auto; gap: 10px; align-items: center; padding: 10px; border: 1px solid #eee; border-radius: 10px; }
    .stock.badge { min-width: 64px; text-align: center; padding: 6px 8px; border-radius: 999px; border: 1px solid #ddd; background: #f7f7f9; font-weight: 700; }
    .stock.badge.low { background: #fff8e1; border-color: #ffe082; }
    .stock.badge.zero { background: #ffebee; border-color: #ffcdd2; color: #b00020; }
    details summary { cursor: pointer; }
    #result-empty { padding: 8px 0; }
  </style>
</head>
<body>
  <h1>病院在庫管理</h1>

  <div class="row">
    <label for="codeInput">バーコード（code）</label><br />
    <input id="codeInput" type="text" inputmode="numeric" placeholder="例: 4901070303885" autocomplete="off" />
  </div>

  <div class="row actions">
    <button class="btn primary" id="searchBtn">検索</button>
    <!-- iOSのみ表示：ショートカット起動ボタン（任意） -->
    <button class="btn" id="iosScanBtn" style="display:none">iPhoneでスキャンして戻る</button>
  </div>

  <div id="status" class="row muted"></div>
  <div id="result" class="grid"></div>

  <div class="row">
    <details>
      <summary>デバッグ（生レスポンス表示）</summary>
      <pre id="debugRaw" class="code" style="white-space: pre-wrap;"></pre>
    </details>
  </div>

  <script>
    // ===== 設定 =====
    // ★ デプロイ済み GAS /exec の URL に置き換えてください
    const GAS_ENDPOINT = 'YOUR_GAS_WEBAPP_URL';

    // （任意）iOSショートカット
    const SHORTCUT_NAME = 'ScanToWeb';
    const RETURN_BASE_URL = location.origin + location.pathname;

    // ===== ユーティリティ =====
    const qs = (sel, el=document) => el.querySelector(sel);
    const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;
    function getQueryParam(name){ const p=new URLSearchParams(location.search); return p.get(name)||''; }
    function showDebug(raw){ const el=qs('#debugRaw'); try{ el.textContent = typeof raw==='string' ? raw : JSON.stringify(raw,null,2);}catch{ el.textContent=String(raw);} }
    function setStatus(text, type='muted'){ const el=qs('#status'); el.textContent=text||''; el.className=`row ${type==='err'?'err':type==='ok'?'ok':'muted'}`; }
    function refocus(){ const i=qs('#codeInput'); setTimeout(()=>{i.focus(); i.select();},0); }

    // ===== レンダリング =====
    let currentCode = '';

    function renderEmpty(code) {
      const box = qs('#result');
      box.innerHTML = `
        <div id="result-empty" class="muted">該当データがありません。</div>
        <div><button id="createBtn" class="btn">在庫0で新規作成</button></div>
      `;
      qs('#createBtn').onclick = async () => {
        try {
          await client.adjust(code, +1);
          await client.adjust(code, -1);
          const rec = await client.get(code);
          renderList(rec ? [rec] : []);
          setStatus('新規作成しました（在庫0）', 'ok');
        } catch { setStatus('新規作成に失敗しました。', 'err'); }
        finally { refocus(); }
      };
    }
    function stockBadgeClass(stock){
      if (!isFinite(stock) || stock <= 0) return 'stock badge zero';
      if (stock <= 2) return 'stock badge low';
      return 'stock badge';
    }
    function renderList(list){
      const box = qs('#result');
      box.innerHTML = '';
      if (!list || list.length === 0){
        renderEmpty(qs('#codeInput').value.trim());
        return;
      }
      const item = list[0];
      const code = item.code ?? '';
      const name = item.name ?? '';
      const stock = Number(item.stock ?? 0);
      currentCode = String(code);

      const wrap = document.createElement('div');
      wrap.className = 'item';
      wrap.innerHTML = `
        <div>
          <div><strong>${name || '(名称未設定)'}</strong></div>
          <div class="muted">code: <span class="code">${code}</span></div>
        </div>
        <div class="${stockBadgeClass(stock)}" data-stock="${isFinite(stock) ? stock : 0}">${isFinite(stock) ? stock : 0}</div>
        <div>
          <button class="btn" data-delta="-1" data-code="${code}">-1</button>
          <button class="btn" data-delta="+1" data-code="${code}">+1</button>
        </div>
      `;
      box.appendChild(wrap);

      const minusBtn = wrap.querySelector('button[data-delta="-1"]');
      if ((isFinite(stock) ? stock : 0) <= 0) { minusBtn.disabled = true; minusBtn.classList.add('warn'); }

      // クリック委譲
      box.onclick = async (ev) => {
        const btn = ev.target.closest('button.btn'); if (!btn) return;
        const code = btn.getAttribute('data-code');
        const delta = parseFloat(btn.getAttribute('data-delta'));

        // 表示在庫で 0 未満防御（UI側）
        const stockEl = btn.closest('.item').querySelector('.stock.badge, .stock.badge.low, .stock.badge.zero');
        const current = Number(stockEl?.dataset.stock ?? 0);
        if (delta < 0 && current <= 0) { setStatus('在庫はこれ以上減らせません（0未満禁止）', 'err'); return; }

        try{
          setStatus(`在庫を ${delta>0?'+':''}${delta} します…`);
          await client.adjust(code, delta);            // 楽観更新（即時反映）＋150msコアレッサ送信
          const rec = await client.get(code);          // 表示を最新化
          renderList(rec ? [rec] : []);
          setStatus('在庫を更新しました。', 'ok');
        }catch{
          setStatus('在庫更新時にエラーが発生しました。', 'err');
        }finally{ refocus(); }
      };
    }

    // ===== A案 v2: アダプティブ・ポーリング ＋ コアレッサ =====
    function createGasClient({ endpoint, activeMs = 1000, idleMs = 5000 }) {
      const map = new Map();   // code -> record
      let   last = '';         // 最新 updated_at（ISO）
      const listeners = new Set();

      // コアレッサ（まとめ送り）
      const queue = new Map(); // code -> 累積delta
      let flushTimer = null;

      // ポーリング制御
      let running = false;
      let backoff = 0;         // 0=通常, 1=1s→2s…指数的
      let nextTick = idleMs;

      const visible = () => !document.hidden;

      async function fetchJSON(url) {
        const txt = await (await fetch(url, { cache: 'no-store' })).text();
        showDebug(txt);
        const j = JSON.parse(txt);
        if (j && j.ok === false) throw new Error(j.error || 'error');
        return j.list || [];
      }

      function snapshot(){ return Array.from(map.values()); }
      function notify(){ listeners.forEach(fn => fn(snapshot())); }
      function subscribe(fn){ listeners.add(fn); return ()=>listeners.delete(fn); }

      async function init(){
        const list = await fetchJSON(`${endpoint}?mode=list`);
        for (const r of list) {
          map.set(String(r.code), r);
          if (r.updated_at && r.updated_at > last) last = r.updated_at;
        }
        startLoop();
        return snapshot();
      }

      function scheduleSoon(ms = 0){ nextTick = Math.min(nextTick, ms); }

      async function pollOnce(){
        const qs = last ? `?mode=changes&since=${encodeURIComponent(last)}` : `?mode=list`;
        const diff = await fetchJSON(`${endpoint}${qs}`);
        let changed = false;
        for (const r of diff) {
          map.set(String(r.code), r);
          if (r.updated_at && r.updated_at > last) last = r.updated_at;
          changed = true;
        }
        if (changed) notify();
        return changed;
      }

      async function loop(){
        running = true;
        while (running){
          try{
            if (visible()) {
              const changed = await pollOnce();
              nextTick = changed ? activeMs : (visible() ? activeMs : idleMs);
              backoff = 0;
            } else {
              await pollOnce();
              nextTick = idleMs;
            }
          } catch (e) {
            backoff = Math.min(backoff ? backoff * 2 : 1000, 20000);
            nextTick = backoff;
          }
          await new Promise(r => setTimeout(r, nextTick));
        }
      }
      function startLoop(){ if (!running){ nextTick = activeMs; loop(); } }
      function stopLoop(){ running = false; }

      // 取得（ローカル即時／初見のみ1回問い合わせ）
      async function get(code){
        const k = String(code);
        if (map.has(k)) return map.get(k);
        const list = await fetchJSON(`${endpoint}?mode=search&code=${encodeURIComponent(k)}`);
        const rec = list[0] || null;
        if (rec){
          map.set(k, rec);
          if (rec.updated_at && rec.updated_at > last) last = rec.updated_at;
          notify();
        }
        return rec;
      }

      // ±1（コアレッサ＋楽観更新）
      function adjust(code, delta){
        const k = String(code);
        const prev = map.get(k);
        const optimistic = { ...(prev||{code:k, name:'', stock:0}), stock: Math.max(0, Number(prev?.stock||0) + delta) };
        map.set(k, optimistic); notify();

        queue.set(k, (queue.get(k) || 0) + delta);
        if (!flushTimer) flushTimer = setTimeout(flushQueue, 150);
      }

      async function flushQueue(){
        const entries = Array.from(queue.entries());
        queue.clear(); flushTimer = null;

        for (const [k, total] of entries) {
          try{
            const list = await fetchJSON(`${endpoint}?mode=adjust&code=${encodeURIComponent(k)}&delta=${encodeURIComponent(total)}`);
            const real = list[0];
            if (real){
              map.set(k, real);
              if (real.updated_at && real.updated_at > last) last = real.updated_at;
              notify();
            }
            scheduleSoon(0); // 追随を早める
          }catch(e){
            // 必要ならロールバック処理を実装（簡略化）
          }
        }
      }

      // 外部イベントで即同期
      window.addEventListener('online',  () => scheduleSoon(0));
      document.addEventListener('visibilitychange', () => scheduleSoon(visible() ? 0 : idleMs));

      return { init, get, adjust, subscribe, snapshot, stopLoop };
    }

    // ===== iOS ショートカット（任意） =====
    function buildShortcutURL(){
      const name = encodeURIComponent(SHORTCUT_NAME);
      const text = encodeURIComponent(RETURN_BASE_URL);
      return `shortcuts://run-shortcut?name=${name}&input=text&text=${text}`;
    }
    function initShortcutButton(){
      const btn = qs('#iosScanBtn'); if (!btn) return;
      if (isIOS) { btn.style.display=''; btn.addEventListener('click', ()=>{ location.href = buildShortcutURL(); }); }
    }

    // ===== 起動処理 =====
    const client = createGasClient({ endpoint: GAS_ENDPOINT, activeMs: 1000, idleMs: 5000 });

    (async function init(){
      if (!GAS_ENDPOINT || GAS_ENDPOINT.includes('https://script.google.com/macros/s/AKfycbzZ-R4mi7duu9Nhr2q4ZmXRS0JQ7tjW4xc6l37fzPDlW5RTPHdr07KObqjRaHQ733m3Og/exec')){
        setStatus('GAS の URL（GAS_ENDPOINT）を設定してください。', 'err'); return;
      }

      try { await client.init(); } catch { setStatus('初期データの取得に失敗しました。', 'err'); }

      const input = qs('#codeInput');
      const btn = qs('#searchBtn');

      // Enterで検索（外部HIDスキャナのEnterも拾える）
      input.addEventListener('keydown', (e)=>{ if (e.key === 'Enter') btn.click(); });

      // 検索ボタンクリック
      btn.addEventListener('click', async ()=>{
        const code = input.value.trim();
        if (!code){ setStatus('code が空です。バーコードを読み取ってください。', 'err'); return; }
        const rec = await client.get(code);   // ローカル即時 or 初見のみサーバ
        renderList(rec ? [rec] : []);
        setStatus(rec ? '検索完了（1件）' : '該当なし', rec ? 'ok' : 'muted');
        refocus();
      });

      // 差分購読：表示中のレコードが更新されたら自動再描画
      client.subscribe(list => {
        if (!currentCode) return;
        const rec = list.find(r => String(r.code) === String(currentCode));
        if (rec) {
          const badge = qs('.stock.badge, .stock.badge.low, .stock.badge.zero');
          if (!badge || Number(badge.dataset.stock) !== Number(rec.stock)) {
            renderList([rec]);
            setStatus('最新データに同期しました。');
          }
        }
      });

      // iOSショートカットボタン
      initShortcutButton();

      // 初回フォーカス & URLクエリからの自動検索
      setTimeout(()=> input.focus(), 0);
      const code = getQueryParam('code');
      if (code){
        input.value = code;
        const rec = await client.get(code);
        renderList(rec ? [rec] : []);
        setStatus(rec ? '検索完了（1件）' : '該当なし', rec ? 'ok' : 'muted');
      }
    })();
  </script>
</body>
</html>









